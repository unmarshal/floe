-- Test new unified let binding syntax

schema Input {
    name: String,
    age: Int64,
    score: Float64,
}

schema Output {
    name: String,
    age: Int64,
    doubleAge: Int64,
}

-- Constant with explicit type
let multiplier : Int = 2

-- Pipeline with explicit type annotation
let transform : Input -> Output =
    map {
        name: .name,
        age: .age,
        doubleAge: .age * multiplier
    }

-- Column function with explicit type annotation
let normalize : String -> String = toLowercase >> trim

main = do
    data <- read "input.parquet" as Input
    result <- data |> transform
    sink "output.parquet" result
